<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Poem Photo Album</title>
    <style>
        .gallery {
            column-count: 4;
            column-gap: 20px;
            padding: 20px;
        }
        .gallery img {
            width: 100%;
            height: auto;
            margin-bottom: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            break-inside: avoid;
            display: block;
        }
        .poem-container {
            width: 100%;
            margin-bottom: 30px;
            break-inside: avoid;
            display: block;
            margin: 0 auto;
        }
        .poem {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.15);
            text-align: center;
            max-width: 400px;
            position: relative;
            overflow: hidden;
            margin: 0 auto;
            border: 2px solid rgba(255,255,255,0.3);
        }
        
        .poem::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255,255,255,0.1);
            backdrop-filter: blur(10px);
            z-index: -1;
        }
        
        .poem h2 {
            margin: 0 0 20px 0;
            font-size: 24px;
            font-weight: 300;
            letter-spacing: 1px;
        }
        .poem p {
            margin: 15px 0;
            line-height: 1.6;
            font-size: 16px;
            font-style: italic;
        }
        
        /* Export button styles */
        .export-container {
            text-align: center;
            margin: 20px 0;
            display: none;
        }
        
        .export-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 25px;
            font-size: 16px;
            font-weight: 500;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            transition: all 0.3s ease;
            margin: 10px;
        }
        
        .export-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
        }
        
        .export-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }
        
        /* Loading indicator */
        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255,255,255,0.3);
            border-radius: 50%;
            border-top-color: white;
            animation: spin 1s ease-in-out infinite;
            margin-right: 10px;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        /* Responsive columns */
        @media (max-width: 1200px) {
            .gallery { column-count: 3; }
        }
        @media (max-width: 900px) {
            .gallery { column-count: 2; }
        }
        @media (max-width: 600px) {
            .gallery { column-count: 1; }
        }
    </style>
    <!-- html2canvas library for exporting to PNG -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
</head>
<body>
    <h1>Poem Photo Album</h1>
    
    <!-- Step 1: Load poems file -->
    <div id="poemsInputContainer" style="text-align: center; margin: 20px 0; padding: 20px; background: #f5f5f5; border-radius: 10px;">
        <h3>Step 1: Load Poems</h3>
        <p>Select the poems.md file to load all poems:</p>
        <input type="file" id="poemsInput" accept=".md,.txt" style="margin: 10px;">
        <div id="poemsStatus" style="margin-top: 10px; font-weight: bold;"></div>
        <div id="poemsDebug" style="margin-top: 10px; font-family: monospace; font-size: 12px; max-height: 200px; overflow-y: auto; text-align: left; background: #fff; padding: 10px; border: 1px solid #ccc; display: none;"></div>
    </div>
    
    <!-- Step 2: Load images -->
    <div id="imagesInputContainer" style="text-align: center; margin: 20px 0; padding: 20px; background: #f0f8ff; border-radius: 10px; display: none;">
        <h3>Step 2: Load Images</h3>
        <p>Select a folder containing your images:</p>
        <input type="file" id="folderInput" webkitdirectory multiple accept="image/*">
    </div>
    
    <!-- Step 3: Enter album title -->
    <div id="titleInputContainer" style="text-align: center; margin: 20px 0; padding: 20px; background: #f0fff0; border-radius: 10px; display: none;">
        <h3>Step 3: Enter Album Title</h3>
        <p>Enter a title for your photo album:</p>
        <input type="text" id="albumTitle" placeholder="Enter album title..." style="padding: 10px; margin: 10px; border-radius: 5px; border: 1px solid #ccc; width: 300px; font-size: 16px;">
        <br>
        <button id="createAlbumBtn" style="padding: 10px 20px; margin: 10px; background: #667eea; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 16px;">Create Album</button>
    </div>
    
    <!-- Export button container -->
    <div class="export-container" id="exportContainer">
        <div style="margin-bottom: 15px;">
            <label style="font-size: 14px; margin-right: 15px;">
                <input type="checkbox" id="watermark-toggle" style="margin-right: 5px;">
                Add Watermark
            </label>
            <input type="text" id="watermark-name" placeholder="Enter name for watermark" 
                   style="padding: 8px 15px; border-radius: 20px; border: 1px solid #ccc; font-size: 14px; width: 250px;">
        </div>
        <button class="export-btn" id="exportBtn" onclick="exportToPNG()">
            Export as JPEG
        </button>
    </div>
    
    <div id="gallery" class="gallery"></div>
    
    <!-- Album title display (hidden initially) -->
    <div id="albumTitleDisplay" style="display: none; text-align: center; padding: 20px; margin-bottom: 20px;">
        <h1 style="font-size: 36px; font-weight: bold; margin: 0; color: #333;"></h1>
    </div>
    
    <canvas id="hiddenCanvas" style="display:none;"></canvas>
    
    <script>
        let poemsData = [];
        
        // Store image data URLs for export
        let imageDataUrls = [];
        
        // Export gallery to PNG using manual canvas drawing (bypasses html2canvas issues)
        async function exportToPNG() {
            const exportBtn = document.getElementById('exportBtn');
            const gallery = document.getElementById('gallery');
            
            if (!gallery.children.length) {
                alert('Please load some images first!');
                return;
            }
            
            // Disable button and show loading state
            exportBtn.disabled = true;
            exportBtn.innerHTML = '<span class="loading"></span>Exporting...';
            
            try {
                // Wait for all images to load completely
                await waitForImagesToLoad();
                
                console.log('Starting manual canvas export...');
                
                // Settings for layout
                const columns = 4;
                const columnWidth = 400;
                const gap = 20;
                const padding = 20;
                const canvasWidth = (columnWidth * columns) + (gap * (columns - 1)) + (padding * 2);
                
                // Collect all elements (images and poems)
                const allChildren = Array.from(gallery.children);
                console.log('Gallery children:', allChildren.length, allChildren.map(el => el.tagName + (el.id ? '#' + el.id : '') + (el.className ? '.' + el.className : '')));
                
                const elements = allChildren.filter(el => 
                    el.tagName === 'IMG' || 
                    el.classList.contains('poem-container') || 
                    el.id === 'albumTitleDisplay'
                );
                
                console.log(`Found ${elements.length} elements to export`);
                
                // If no elements found, try getting images directly
                if (elements.length === 0) {
                    console.log('No elements found with filter, trying direct query...');
                    const directImages = gallery.querySelectorAll('img');
                    console.log('Direct image query found:', directImages.length);
                }
                
                // Calculate heights for each column
                const columnHeights = new Array(columns).fill(padding);
                const elementPositions = [];
                
                // First pass: calculate positions for all elements
                for (const element of elements) {
                    // Title spans all columns
                    if (element.id === 'albumTitleDisplay') {
                        const titleHeight = 80;
                        elementPositions.push({
                            element,
                            type: 'title',
                            x: padding,
                            y: padding,
                            width: canvasWidth - (padding * 2),
                            height: titleHeight
                        });
                        // Advance all columns past title
                        for (let i = 0; i < columns; i++) {
                            columnHeights[i] = padding + titleHeight + gap;
                        }
                        continue;
                    }
                    
                    // Find shortest column
                    let shortestCol = 0;
                    for (let i = 1; i < columns; i++) {
                        if (columnHeights[i] < columnHeights[shortestCol]) {
                            shortestCol = i;
                        }
                    }
                    
                    const x = padding + (shortestCol * (columnWidth + gap));
                    const y = columnHeights[shortestCol];
                    
                    if (element.tagName === 'IMG') {
                        // Calculate image height maintaining aspect ratio
                        const aspectRatio = element.naturalHeight / element.naturalWidth;
                        const height = columnWidth * aspectRatio;
                        
                        elementPositions.push({
                            element,
                            type: 'image',
                            x,
                            y,
                            width: columnWidth,
                            height
                        });
                        
                        columnHeights[shortestCol] += height + gap;
                    } else if (element.classList.contains('poem-container')) {
                        // Poem card - estimate height
                        const poemHeight = 300; // Fixed height for poem cards
                        
                        elementPositions.push({
                            element,
                            type: 'poem',
                            x,
                            y,
                            width: columnWidth,
                            height: poemHeight
                        });
                        
                        columnHeights[shortestCol] += poemHeight + gap;
                    }
                }
                
                // Calculate total canvas height
                const canvasHeight = Math.max(...columnHeights) + padding;
                
                console.log(`Canvas size: ${canvasWidth}x${canvasHeight}`);
                
                // Create canvas
                const canvas = document.createElement('canvas');
                canvas.width = canvasWidth;
                canvas.height = canvasHeight;
                const ctx = canvas.getContext('2d');
                
                // Fill background
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, canvasWidth, canvasHeight);
                
                // Draw each element
                for (const pos of elementPositions) {
                    if (pos.type === 'title') {
                        // Draw title
                        ctx.fillStyle = '#333333';
                        ctx.font = 'bold 36px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText(albumTitle, canvasWidth / 2, pos.y + 45);
                        
                        // Draw underline
                        ctx.strokeStyle = '#667eea';
                        ctx.lineWidth = 3;
                        const textWidth = ctx.measureText(albumTitle).width;
                        ctx.beginPath();
                        ctx.moveTo((canvasWidth - textWidth) / 2, pos.y + 55);
                        ctx.lineTo((canvasWidth + textWidth) / 2, pos.y + 55);
                        ctx.stroke();
                        
                    } else if (pos.type === 'image') {
                        // Draw image with rounded corners
                        ctx.save();
                        roundRect(ctx, pos.x, pos.y, pos.width, pos.height, 8);
                        ctx.clip();
                        ctx.drawImage(pos.element, pos.x, pos.y, pos.width, pos.height);
                        ctx.restore();
                        
                        // Draw shadow effect (border)
                        ctx.strokeStyle = 'rgba(0,0,0,0.1)';
                        ctx.lineWidth = 1;
                        roundRect(ctx, pos.x, pos.y, pos.width, pos.height, 8);
                        ctx.stroke();
                        
                    } else if (pos.type === 'poem') {
                        // Draw poem card with gradient background
                        const gradient = ctx.createLinearGradient(pos.x, pos.y, pos.x + pos.width, pos.y + pos.height);
                        gradient.addColorStop(0, '#667eea');
                        gradient.addColorStop(1, '#764ba2');
                        
                        ctx.fillStyle = gradient;
                        roundRect(ctx, pos.x, pos.y, pos.width, pos.height, 15);
                        ctx.fill();
                        
                        // Get poem text
                        const poemDiv = pos.element.querySelector('.poem');
                        const title = poemDiv.querySelector('h2')?.textContent || '';
                        const paragraphs = poemDiv.querySelectorAll('p');
                        
                        ctx.fillStyle = '#ffffff';
                        ctx.textAlign = 'center';
                        
                        // Draw title
                        ctx.font = '300 20px Arial';
                        ctx.fillText(title, pos.x + pos.width / 2, pos.y + 40);
                        
                        // Draw poem lines
                        ctx.font = 'italic 14px Arial';
                        let lineY = pos.y + 70;
                        paragraphs.forEach(p => {
                            const lines = p.innerHTML.split('<br>');
                            lines.forEach(line => {
                                const text = line.replace(/<[^>]*>/g, '').trim();
                                if (text && lineY < pos.y + pos.height - 20) {
                                    ctx.fillText(text, pos.x + pos.width / 2, lineY);
                                    lineY += 22;
                                }
                            });
                            lineY += 10; // Gap between stanzas
                        });
                    }
                }
                
                // Add watermark if enabled
                const includeWatermark = document.getElementById('watermark-toggle').checked;
                const watermarkName = document.getElementById('watermark-name').value.trim();
                
                if (includeWatermark && watermarkName) {
                    // Watermark dimensions (with rotation considered)
                    const fontSize = 48;
                    const watermarkWidth = watermarkName.length * fontSize * 0.6;
                    const watermarkHeight = fontSize;
                    const diagonalSize = Math.sqrt(watermarkWidth * watermarkWidth + watermarkHeight * watermarkHeight);
                    
                    // Calculate spacing to fill the page
                    const horizontalSpacing = diagonalSize * 1.0;
                    const verticalSpacing = diagonalSize * 1.0;
                    
                    // Calculate number of rows and columns needed
                    const cols = Math.ceil(canvasWidth / horizontalSpacing) + 2;
                    const rows = Math.ceil(canvasHeight / verticalSpacing) + 2;
                    
                    // Draw watermarks
                    ctx.save();
                    ctx.font = '300 48px Georgia';
                    ctx.fillStyle = 'rgba(218, 165, 32, 0.15)';
                    ctx.textAlign = 'center';
                    
                    for (let row = 0; row < rows; row++) {
                        for (let col = 0; col < cols; col++) {
                            const topPos = (row * verticalSpacing) - diagonalSize;
                            const leftPos = (col * horizontalSpacing) - diagonalSize;
                            
                            const watermarkCenterX = leftPos + diagonalSize/2;
                            const watermarkCenterY = topPos + diagonalSize/2;
                            
                            // Check if this watermark overlaps with any image
                            let overlapsImage = false;
                            for (const pos of elementPositions) {
                                if (pos.type === 'image') {
                                    // Check if watermark center is within image bounds (with some padding)
                                    if (watermarkCenterX >= pos.x - 50 && watermarkCenterX <= pos.x + pos.width + 50 &&
                                        watermarkCenterY >= pos.y - 50 && watermarkCenterY <= pos.y + pos.height + 50) {
                                        overlapsImage = true;
                                        break;
                                    }
                                }
                            }
                            
                            // Only draw watermark if it doesn't overlap with images
                            if (!overlapsImage) {
                                ctx.save();
                                ctx.translate(watermarkCenterX, watermarkCenterY);
                                ctx.rotate(-45 * Math.PI / 180);
                                ctx.fillText(watermarkName, 0, 0);
                                ctx.restore();
                            }
                        }
                    }
                    
                    ctx.restore();
                }
                
                // Convert canvas to JPEG and download
                const dataUrl = canvas.toDataURL('image/jpeg', 0.9);
                
                console.log('Export data URL length:', dataUrl.length);
                
                const link = document.createElement('a');
                link.href = dataUrl;
                link.download = `enamor-photo-album-${new Date().toISOString().split('T')[0]}.jpg`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                console.log('Export completed successfully');
                
                // Reset button
                exportBtn.disabled = false;
                exportBtn.innerHTML = 'Export as JPEG';
                
            } catch (error) {
                console.error('Export failed:', error);
                alert('Export failed: ' + error.message);
                exportBtn.disabled = false;
                exportBtn.innerHTML = 'Export as JPEG';
            }
        }
        
        // Helper function to draw rounded rectangle
        function roundRect(ctx, x, y, width, height, radius) {
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.lineTo(x + width - radius, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
            ctx.lineTo(x + width, y + height - radius);
            ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
            ctx.lineTo(x + radius, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
            ctx.lineTo(x, y + radius);
            ctx.quadraticCurveTo(x, y, x + radius, y);
            ctx.closePath();
        }
        
        // Wait for all images to load completely with progress tracking
        function waitForImagesToLoad() {
            return new Promise((resolve) => {
                const images = document.querySelectorAll('#gallery img');
                if (images.length === 0) {
                    resolve();
                    return;
                }
                
                let loadedCount = 0;
                const totalImages = images.length;
                
                console.log(`Waiting for ${totalImages} images to load...`);
                
                function imageLoaded(img, index) {
                    loadedCount++;
                    console.log(`Image ${index + 1}/${totalImages} loaded (${img.src.substring(0, 50)}...)`);
                    
                    if (loadedCount === totalImages) {
                        console.log('All images loaded! Starting export...');
                        // Additional delay to ensure all rendering is complete
                        setTimeout(resolve, 1000);
                    }
                }
                
                images.forEach((img, index) => {
                    if (img.complete && img.naturalHeight !== 0) {
                        imageLoaded(img, index);
                    } else {
                        img.addEventListener('load', () => imageLoaded(img, index));
                        img.addEventListener('error', () => {
                            console.warn(`Image ${index + 1} failed to load, continuing...`);
                            imageLoaded(img, index);
                        });
                    }
                });
            });
        }
        
        // Function to parse poems.md file and extract individual poems
        function parsePoemsFile(markdownContent) {
            console.log('Starting to parse poems.md...');
            console.log('Raw content length:', markdownContent.length);
            
            // First, let's clean up the content and remove the frontmatter
            let cleanContent = markdownContent;
            
            // Remove YAML frontmatter if present (between --- at start)
            if (cleanContent.startsWith('---')) {
                const frontmatterEnd = cleanContent.indexOf('---', 3);
                if (frontmatterEnd !== -1) {
                    cleanContent = cleanContent.substring(frontmatterEnd + 3).trim();
                    console.log('Removed frontmatter, new length:', cleanContent.length);
                }
            }
            
            // Split by standalone "---" lines (poem separators)
            const rawSections = cleanContent.split(/\n---\s*\n|\r\n---\s*\r?\n/);
            console.log(`Found ${rawSections.length} raw sections after splitting by ---`);
            
            const poems = [];
            
            rawSections.forEach((section, index) => {
                section = section.trim();
                console.log(`Processing section ${index + 1}:`, section.substring(0, 100) + '...');
                
                if (!section || section.length < 10) {
                    console.log(`Skipping section ${index + 1} - too short or empty`);
                    return;
                }
                
                // Look for poem title (starts with ##)
                const lines = section.split(/\r?\n/);
                let titleLine = '';
                let contentLines = [];
                let foundTitle = false;
                
                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i].trim();
                    
                    if (line.startsWith('## ') && !foundTitle) {
                        titleLine = line.replace('## ', '').trim();
                        foundTitle = true;
                        console.log(`Found poem title: "${titleLine}"`);
                    } else if (foundTitle && line && !line.startsWith('#') && !line.startsWith('*Generated by')) {
                        // Only add non-empty lines that aren't headers or footer text
                        contentLines.push(line);
                    }
                }
                
                if (titleLine && contentLines.length > 0) {
                    const poemContent = contentLines.join('\n').trim();
                    poems.push({
                        title: titleLine,
                        content: poemContent
                    });
                    console.log(`Successfully parsed poem: "${titleLine}" with ${contentLines.length} lines`);
                } else {
                    console.log(`Skipping section ${index + 1} - no valid title or content found`);
                    console.log(`  Title found: ${!!titleLine}`);
                    console.log(`  Content lines: ${contentLines.length}`);
                }
            });
            
            console.log(`PARSING COMPLETE: Successfully extracted ${poems.length} individual poems`);
            return poems;
        }
        
        // Function to create HTML for a poem
        function createPoemHtml(title, content) {
            const stanzas = content.split(/\n\s*\n/).filter(stanza => stanza.trim());
            const stanzaHtml = stanzas.map(stanza => {
                const lines = stanza.trim().split('\n').map(line => line.trim()).filter(line => line);
                return `<p>${lines.join('<br>')}</p>`;
            }).join('');
            
            return `<div class="poem">
                        <h2>${title}</h2>
                        ${stanzaHtml}
                    </div>`;
        }
        
        // Load poems from user-selected file
        document.getElementById('poemsInput').addEventListener('change', function(e) {
            const file = e.target.files[0];
            const statusDiv = document.getElementById('poemsStatus');
            const debugDiv = document.getElementById('poemsDebug');
            
            if (!file) {
                statusDiv.textContent = '';
                debugDiv.style.display = 'none';
                return;
            }
            
            statusDiv.textContent = 'Loading poems...';
            statusDiv.style.color = 'blue';
            
            const reader = new FileReader();
            reader.onload = function(event) {
                try {
                    const markdownContent = event.target.result;
                    console.log('Successfully loaded poems file');
                    console.log('File content length:', markdownContent.length);
                    
                    // Show debug info
                    debugDiv.innerHTML = `
                        <strong>Debug Info:</strong><br>
                        File size: ${markdownContent.length} characters<br>
                        First 300 characters:<br>
                        <pre>${markdownContent.substring(0, 300)}</pre>
                    `;
                    debugDiv.style.display = 'block';
                    
                    poemsData = parsePoemsFile(markdownContent);
                    console.log(`‚úÖ SUCCESS: Loaded ${poemsData.length} individual poems from file`);
                    
                    if (poemsData.length > 0) {
                        statusDiv.textContent = `‚úÖ Loaded ${poemsData.length} poems successfully!`;
                        statusDiv.style.color = 'green';
                        
                        // Show the images input section
                        document.getElementById('imagesInputContainer').style.display = 'block';
                        
                        // Log each poem title for verification
                        poemsData.forEach((poem, index) => {
                            console.log(`Poem ${index + 1}: "${poem.title}"`);
                        });
                        
                        // Add poem titles to debug
                        const poemTitles = poemsData.map((poem, i) => `${i + 1}. ${poem.title}`).join('<br>');
                        debugDiv.innerHTML += `<br><strong>Found poems:</strong><br>${poemTitles}`;
                    } else {
                        statusDiv.textContent = '‚ùå No poems found in the file. Check the format.';
                        statusDiv.style.color = 'red';
                    }
                } catch (error) {
                    console.error('‚ùå ERROR parsing poems file:', error);
                    statusDiv.textContent = '‚ùå Error loading poems file. Please check the file format.';
                    statusDiv.style.color = 'red';
                    
                    debugDiv.innerHTML = `<strong>Error:</strong><br>${error.message}`;
                    debugDiv.style.display = 'block';
                }
            };
            
            reader.onerror = function() {
                statusDiv.textContent = '‚ùå Error reading the file.';
                statusDiv.style.color = 'red';
            };
            
            reader.readAsText(file);
        });
        
        // Initialize with empty poems data - user must load poems first
        poemsData = [];
        let loadedImages = [];
        let albumTitle = '';

        // Handle Step 2: Images folder selection
        document.getElementById('folderInput').addEventListener('change', function(e) {
            const filePromises = [];
            for (let file of e.target.files) {
                if (file.type.startsWith('image/')) {
                    const promise = new Promise((resolve) => {
                        const reader = new FileReader();
                        reader.onload = function(e) {
                            const img = document.createElement('img');
                            img.src = e.target.result;
                            img.alt = file.name;
                            img.title = file.name;
                            img.crossOrigin = 'anonymous';
                            resolve(img);
                        };
                        reader.readAsDataURL(file);
                    });
                    filePromises.push(promise);
                }
            }
            
            Promise.all(filePromises).then(images => {
                loadedImages = images;
                console.log(`üì∑ Loaded ${loadedImages.length} images`);
                
                if (loadedImages.length > 0) {
                    // Show step 3: title input
                    document.getElementById('titleInputContainer').style.display = 'block';
                }
            });
        });

        // Handle Step 3: Create album with title
        document.getElementById('createAlbumBtn').addEventListener('click', function() {
            const titleInput = document.getElementById('albumTitle');
            albumTitle = titleInput.value.trim();
            
            if (!albumTitle) {
                alert('Please enter a title for your album');
                return;
            }
            
            if (loadedImages.length === 0) {
                alert('Please load images first');
                return;
            }
            
            if (poemsData.length === 0) {
                alert('Please load poems first');
                return;
            }
            
            createPhotoAlbum();
        });

        function createPhotoAlbum() {
            const gallery = document.getElementById('gallery');
            gallery.innerHTML = '';
            
            console.log(`üì∑ Processing ${loadedImages.length} images`);
            console.log(`üìù Available poems: ${poemsData.length}`);
            console.log(`üìñ Album title: "${albumTitle}"`);
            
            // Use all available poems from poems.md file
            const numPoems = poemsData.length;
            console.log(`üéØ Will use all ${numPoems} poems from poems.md for the gallery`);
            
            // Select random poems
            const shuffledPoems = [...poemsData].sort(() => Math.random() - 0.5);
            const selectedPoems = shuffledPoems.slice(0, numPoems);
            
            console.log('üé≤ Selected poems:');
            selectedPoems.forEach((poem, index) => {
                console.log(`  ${index + 1}. "${poem.title}"`);
            });
            
            // Create poem containers
            const poemContainers = [];
            selectedPoems.forEach((poem, index) => {
                const poemContainer = document.createElement('div');
                poemContainer.className = 'poem-container';
                poemContainer.innerHTML = createPoemHtml(poem.title, poem.content);
                poemContainers.push(poemContainer);
                console.log(`‚ú® Created poem card ${index + 1}: "${poem.title}"`);
            });
            
            // Calculate even distribution positions for poems
            const totalElements = loadedImages.length + poemContainers.length;
            const spacing = Math.floor(totalElements / poemContainers.length);
            
            console.log(`üìê Distributing ${poemContainers.length} poems evenly among ${totalElements} total elements`);
            console.log(`üìè Spacing between poems: approximately every ${spacing} elements`);
            
            // Create final ordered array with even distribution
            const orderedElements = [];
            let imageIndex = 0;
            let poemIndex = 0;
            
            for (let i = 0; i < totalElements; i++) {
                // Determine if this position should have a poem
                const shouldPlacePoem = poemIndex < poemContainers.length && 
                                       (i === Math.floor((poemIndex + 1) * spacing - 1) || 
                                        (i === totalElements - poemContainers.length + poemIndex && imageIndex >= loadedImages.length));
                
                if (shouldPlacePoem) {
                    orderedElements.push(poemContainers[poemIndex]);
                    console.log(`üìù Placed poem "${selectedPoems[poemIndex].title}" at position ${i + 1}`);
                    poemIndex++;
                } else if (imageIndex < loadedImages.length) {
                    orderedElements.push(loadedImages[imageIndex]);
                    imageIndex++;
                }
            }
            
            // Append all elements to gallery in the calculated order
            orderedElements.forEach((element, index) => {
                gallery.appendChild(element);
            });
            
            console.log(`üé® Gallery complete: ${loadedImages.length} images + ${poemContainers.length} evenly distributed poem cards`);
            
            // Hide UI elements and show the album with title
            if (loadedImages.length > 0) {
                // Hide all step containers
                document.getElementById('poemsInputContainer').style.display = 'none';
                document.getElementById('imagesInputContainer').style.display = 'none';
                document.getElementById('titleInputContainer').style.display = 'none';
                
                // Hide the main title
                document.querySelector('h1').style.display = 'none';
                
                // Show and set the album title
                const albumTitleDisplay = document.getElementById('albumTitleDisplay');
                albumTitleDisplay.querySelector('h1').textContent = albumTitle;
                albumTitleDisplay.style.display = 'block';
                albumTitleDisplay.style.position = 'static'; // Changed from fixed to static for export
                albumTitleDisplay.style.textAlign = 'center';
                albumTitleDisplay.style.margin = '20px 0';
                albumTitleDisplay.style.padding = '20px';
                
                // Add beautiful line under title
                const titleElement = albumTitleDisplay.querySelector('h1');
                titleElement.style.borderBottom = '3px solid #667eea';
                titleElement.style.paddingBottom = '15px';
                titleElement.style.marginBottom = '0';
                
                // Show the export button
                document.getElementById('exportContainer').style.display = 'block';
                
                // Make gallery take full screen with minimal top margin
                const gallery = document.getElementById('gallery');
                gallery.style.margin = '20px 0 0 0'; // Reduced margin since title is now in document flow
                gallery.style.padding = '10px';
                
                // Insert title at the beginning of gallery for export
                gallery.insertBefore(albumTitleDisplay, gallery.firstChild);
                
                // Remove body margins/padding for full screen effect
                document.body.style.margin = '0';
                document.body.style.padding = '0';
                
                // Position export button at top right corner to avoid overlap
                const exportContainer = document.getElementById('exportContainer');
                exportContainer.style.position = 'fixed';
                exportContainer.style.top = '20px';
                exportContainer.style.right = '20px'; // Changed from center to right
                exportContainer.style.left = 'auto';
                exportContainer.style.transform = 'none'; // Removed center transform
                exportContainer.style.zIndex = '1000';
                exportContainer.style.backgroundColor = 'rgba(255,255,255,0.95)';
                exportContainer.style.padding = '10px';
                exportContainer.style.borderRadius = '25px';
                exportContainer.style.boxShadow = '0 2px 10px rgba(0,0,0,0.1)';
            }
        }
    </script>
</body>
</html>